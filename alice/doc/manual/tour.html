<?php include("macros.php3"); ?>
<?php heading("A Tour to Wonderland", "A Tour to Wonderland") ?>

<A href="http://www.ps.uni-sb.de/~rossberg/"><I>Andreas Rossberg</I></A>

<?php section("overview", "overview") ?>

<P>This page is meant as a short introduction to the Alice language and system
and its features:</P>

<UL>
  <LI><A href="#sml">Standard ML compatibility</A></LI>
  <LI><A href="#interactive">Interactive use</A>: evaluating declarations and
  browsing results</LI>
  <LI><A href="#laziness">Laziness</A>: transparent lazy evaluation</LI>
  <LI><A href="#concurrency">Concurrency</A>: threads and data-flow
  synchronistation</LI>
  <LI><A href="#promises">Promises</A>: handled futures</LI>
  <LI><A href="#packages">Packages</A>: dynamic typing and first-class modules</LI>
  <LI><A href="#pickling">Pickling</A>: platform independent persistence</LI>
  <LI><A href="#components">Components</A>: platform independence and
  lazy dynamic linking</LI>
  <LI><A href="#distribution">Distribution</A>: remote processes and proxies</LI>
  <LI><A href="#constraints">Constraints</A>: concurrent constraint programming
  and programmable search</LI>
  <?php if ($platform != "seam") { ?>
  <LI><A href="#interop">Interoperability</A>: working hand in hand with Oz
  programs</LI>
  <?php } ?>
</UL>


<?php section("sml", "standard ML") ?>

<P>Alice ML is an extension of the <A
href="http://cm.bell-labs.com/cm/cs/what/smlnj/sml.html">Standard ML</A>
language (SML). Most of the examples shown here assume a working knowledge of
functional programming in general and SML in particular. There are numerous
books and tutorials available for SML.</P>

<P>Online Material:</P>

<UL>
  <LI><A href="http://www-2.cs.cmu.edu/~rwh/smlbook/">Programming in
  Standard ML</A>, by Robert Harper, CMU</LI>
  <LI><A href="http://www.dcs.ed.ac.uk/home/stg/NOTES/">Programming in Standard
  ML '97: An Online Tutorial</A>, by Stephen Gilmore, University of
  Edinburgh</LI>
</UL>

<P>Paper Books:</P>

<UL>
  <LI><A href="http://www.cl.cam.ac.uk/users/lcp/MLbook/">ML for the Working
  Programmer</A> (2nd edition), by Larry Paulson. Cambridge University
  Press</LI>
  <LI><A href="http://www-db.stanford.edu/~ullman/emlp.html">Elements of ML
  Programming</A> (ML'97 edition), by Jeffrey Ullmann. Prentice-Hall</LI>
</UL>

<P>The definition of the language and its library can be found here:</P>

<UL>
  <LI><A href="http://mitpress.mit.edu/catalog/item/default.asp?sid=E868B22B-D3BB-46D3-95EF-9D010C912B4F&ttype=2&tid=3874">The
  Definition of Standard ML</A> (Revised), by Robin Milner, Mads Tofte,
  Robert Harper, Dave MacQueen. The MIT Press</LI>
  <LI><A href="http://titles.cambridge.org/catalogue.asp?isbn=0521794781">The Standard ML
  Basis Library</A>, by John Reppy and Emden Gansner (Eds.).
  Cambridge University Press
  (<A href="http://www.standardml.org/Basis/">preliminary version is online</A>)
  </LI>
</UL>

<P>For a more comprehensive literature list, see the
<A href="http://www.smlnj.org/doc/literature.html#tutorials">bibliography</A>
on the SML/NJ site.</P>


<?php section("interactive", "interactive toplevel") ?>

<P>Alice ML is an extension of Standard ML, and the Alice
<A href="interactive.html">interactive toplevel</A>
works very similar to the interactive prompts known from other SML
systems, where you can type in expressions and declarations to evaluate them.
Input is terminated with a semicolon. For example, you might simply perform a
simple calculation:</P>

<PRE class=code>
- 4+5;
<I><SMALL>val it : int = 9</SMALL></I></PRE>

<P>The expression is evaluated and the result <TT>9</TT> printed along with
its inferred type <TT>int</TT>. Anonymous expressions get the name <TT>it</TT>,
so that you can refer to them in consecutive inputs:</P>

<PRE class=code>
- 2*it;
<I><SMALL>val it : int = 18</SMALL></I></PRE>

<DIV class=note>
<P><I>Note:</I> We only use and describe the simple <A href="interactive.html#text">text interface</A> to the toplevel in this tour. There also is a <A href="interactive.html#gui">graphical frontend</A>, which works similarly, but offers more features.</P>
</DIV>

<P>We can also try the one-line Hello World program:</P>

<PRE class=code>
- print "Hello world!\n";
<I><SMALL>Hello world!
val it : unit = ()</SMALL></I></PRE>

<DIV class=note>
<P><I>Note:</I> In the rest of this tour we will present
program fragments in their pure form, without showing the interactive prompt or
the semicolon terminating the interactive input. For example, the last
interaction will be displayed simply as</P>
</DIV>

<PRE class=code>
print "Hello world!\n"
<I><SMALL>Hello world!
val it : unit = ()</SMALL></I></PRE>

<P>Entering a function declaration is more interesting. For example,
the factorial function:<P>

<PRE class=code>
fun fac 0 = 1
  | fac n = n * fac (n-1)
<I><SMALL>val fac : int -> int = _fn</SMALL></I></PRE>

<P>This time, the result has a more complex type: it is a function from
integers to integers. We can apply that function:</P>

<PRE class=code>
fac 12
<I><SMALL>val it : int = 479001600</SMALL></I></PRE>

<P>If a computation takes too long you can abort it in the interactive toplevel by entering Ctrl-C. For example:<P>

<PRE class=code>
fun loop () = loop ()
<I><SMALL>val loop : unit -> '1 = _fn</SMALL></I>
loop ()
&lt;Ctrl-C&gt;
<I><SMALL>interrupted</SMALL></I></PRE>

<DIV class=note>
<P><I>Note:</I> In the <A href="interactive.html#gui">graphical interface</A> to the toplevel you have to interrupt a computation by invoking the respective command from the <I>Eval</I> menu. The keyboard shortcut is Ctrl-I.</P>
</DIV>

<P>Unlike with other ML systems, you can also put a computation into background instead of interrupting it, by pressing Ctrl-Z (Ctrl-Break on Windows):</P>

<PRE class=code>
loop ()
&lt;Ctrl-Z&gt;
<I><SMALL>val it : '1 = _future</SMALL></I></PRE>

<P>This feature is useful if you still want to use the result of the computation later on but do not want to wait for it now. The result of a background computation is represented by futures, see the <A href="#concurrency">discussion of concurrency</A> below.</P>

<P>The interactive toplevel (in <A href="interactive.html#text">text mode</A>) is exited with Ctrl-D (Ctrl-Z on Windows), or by calling <TT>exit()</TT>.</P>

<DIV class=note>
<P><I>Note:</I> Under Windows, depending on the shell used, Ctrl characters may not work as expected. We recommend using zsh under Cygwin, or the SML mode for Emacs. On Linux, certain command line editing tools like <TT>rlwrap</TT> might interfer with some of the Ctrl characters as well.
In case of problems, we suggest using the <A href="interactive.html#gui">graphical mode</A> of the toplevel.</P>
</DIV>

<?php subsection("interactive-inspector", "The Inspector") ?>

<P>For more complex values, plain static output of the result is often
insufficient. The Alice system includes the <A
href="library/inspector.html"><EM>Inspector</EM></A> for browsing arbitrary data
structures interactively:</P>

<PRE class=code>
inspect (List.tabulate (10, fn i => (i, i*i, i*i*i)))
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P>An Inspector window will pop up displaying the table of square and cubic
numbers:</P>

<P align=center><IMG src="inspector-intro-1.png" border=0 alt="Alice Inspector"></P>

<P>When you inspect additional values, they will be displayed in the same
Inspector window. The inspector can be used to browse arbitrary data
structures:</P>

<PRE class=code>
val r = ref 56
<I><SMALL>val r : int ref = ref 56</SMALL></I>
inspect (3 + 8, SOME 3.141592, {hello = "hello, world"}, r, [true, 4 < 3])
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P align=center><IMG src="inspector-intro-2.png" border=0 alt="Alice Inspector"></P>

<P class=note><EM>Note:</EM> If the size of the inspected data structure
exceeds certain configurable limits, parts of the output will be hidden. Those
parts are represented by <?php if ($platform != "seam") { ?>arrows,<?php } else { ?>dots,<?php } ?> which can be interactively unfolded if
desired.</P>

<?php if ($platform == "seam") { ?>
<P>Note the index put after the <TT>ref</TT> constructor in the Inspector window. All displayed references and futures are decorated by such an index to indicate which of them are identical.</P>
<?php } ?>

<P>The Inspector concurrently watches the data structures it shows. If they
change, it will automatically update its display. For example, if you re-assign
a reference the Inspector window will be updated automatically:</P>

<PRE class=code>
r := 33033
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P align=center><IMG src="inspector-intro-3.png" border=0 alt="Alice Inspector"></P>

<!--
<PRE class=code>
val rec infiniteList = 1::infiniteList
<I>val infiniteList : int list =
   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]</I>
inspect infiniteList
<I>val it : unit = ()</I></PRE>

<PRE class=code>
inspect (Future.alarm (Time.fromMilliseconds (Int.toLarge 2000)))
<I>val it : unit = ()</I></PRE>
-->

<?php if ($platform == "seam") { ?>
<P>You can select any part of a displayed value by clicking on it. If you hover over the selection with the mouse the inspector will show the value's type as a tool tip.

<P align=center><IMG src="inspector-intro-4.png" border=0 alt="Alice Inspector"></P>
<?php } ?>

<P>You can clear the Inspector window by choosing <I>Clear</I> from the <I>Inspector</I> menu.</P>


<?php section("laziness", "laziness") ?>

<P>While Standard ML is a fully eager (strict) language, Alice ML provides
support for optional lazy evaluation. Any expression can be evaluated lazily by
preceeding it with the <TT>lazy</TT> keyword:</P>

<PRE class=code>
val x = lazy 4+5
<I><SMALL>val x : int = _lazy</SMALL></I></PRE>

<P>Lazy suspensions are represented by the <TT>_lazy</TT> notation in the
interactive toplevel's output, as shown above. The value of <TT>x</TT> will not
be computed before it is actually required. For example,</P>

<PRE class=code>
(x,x)
<I><SMALL>val it : int * int = (_lazy, _lazy)</SMALL></I>
x
<I><SMALL>val it : int = _lazy</SMALL></I>
fun pair x = (x,x)
<I><SMALL>val pair : 'a -> 'a * 'a = _fn</SMALL></I>
pair x
<I><SMALL>val it : int * int = (_lazy, _lazy)</SMALL></I>
x > 10
<I><SMALL>val it : bool = false</SMALL></I>
x
<I><SMALL>val it : int = 9</SMALL></I></PRE>

<P>Tupling is parametric in its components and does not trigger <TT>x</TT>. 
Neither does applying it to a function whose body does not trigger its argument, like <TT>pair</TT> above.
The comparison operator <TT>></TT> is <I>future-strict</I> in its arguments, however, and hence
forces evaluation of <TT>x</TT>. Likewise, pattern matching, arithmetic
operations, comparison (<TT>op=</TT>) or similar operations can force a
value.</P>

<P>As a simple example of a lazy function, consider a generator for lazy
streams of numbers:</P>

<PRE class=code>
fun enum n = lazy n :: enum (n+1)
<I><SMALL>val enum : int -> int list = _fn</SMALL></I>
val ns = enum 0
<I><SMALL>val ns : int list = _lazy</SMALL></I>
List.nth (ns,5)
<I><SMALL>val it : int = 5</SMALL></I>
ns
<I><SMALL>val it : int list = 0 :: 1 :: 2 :: 3 :: 4 :: 5 :: _lazy</SMALL></I></PRE>

<P>In this example, requesting the 5th element of the list forced partial
evaluation of the list, up to that element.</P>

<P>We can define a lazy variant of the <TT>map</TT> function:</P>

<PRE class=code>
fun mapz f xs = lazy (case xs of nil    => nil
                               | x::xs' => f x :: mapz f xs')
<I><SMALL>val mapz : ('a -> 'b) -> 'a list -> 'b list = _fn</SMALL></I></PRE>

<P>Note that the <TT>case</TT> expression must be nested inside the
<TT>lazy</TT> expression - otherwise applying <TT>mapz</TT> would trigger
evaluation of the head of the list, to perform the necessary pattern matching.
Function declarations support syntactic sugar that allows expressing the same
definition more elegantly:</P>

<PRE class=code>
fun lazy mapz f nil     = nil
       | mapz f (x::xs) = f x :: mapz f xs
<I><SMALL>val mapz : ('a -> 'b) -> 'a list -> 'b list = _fn</SMALL></I></PRE>

<P>This derived form is defined such that both definitions of <TT>mapz</TT> are
equivalent. Let us apply <TT>mapz</TT> to the stream of natural numbers
to calculate their factorials lazily:</P>

<PRE class=code>
val facs = mapz fac (enum 0)
<I><SMALL>val facs : int list = _lazy</SMALL></I>
List.take (facs,7)
<I><SMALL>val it : int list = [1, 1, 2, 6, 24, 120, 720]</SMALL></I>
facs
<I><SMALL>val it : int list = 1 :: 1 :: 2 :: 6 :: 24 :: 120 :: 720 :: _lazy</SMALL></I></PRE>

<P>The Inspector observes when lazy suspensions are triggered. If
you evaluate</P>

<PRE class=code>
inspect facs
<I><SMALL>val it : unit = ()</SMALL></I>
List.nth (facs,10)
<I><SMALL>val it : int = 3628800</SMALL></I></PRE>

<P>it will automatically update its window to reflect the substitution of the
lazy tail of <TT>facs</TT> by a (partial) list.<!-- The Inspector also allows you to investigate the type of the lazy suspensions.--></P>

<P align=center><IMG src="inspector-lazy-1.png" border=0 alt="Alice Inspector"></P>

<P>Here is a lazy version of the <TT>zip</TT> function:</P>

<PRE class=code>
fun lazy zipz (x::xs, y::ys) = (x,y) :: zipz (xs,ys)
       | zipz       _        = nil
<I><SMALL>val zipz : 'a list * 'b list -> ('a * 'b) list = _fn</SMALL></I></PRE>

<P>It is possible to calculate the stream of Fibonacci numbers using
<TT>mapz</TT> and <TT>zipz</TT>:</P>

<PRE class=code>
val rec fibs = 1 :: 1 :: (lazy mapz op+ (zipz (fibs, tl fibs)))
<I><SMALL>val it : int list = 1 :: 1 :: _lazy</SMALL></I>
List.nth (fibs, 10)
<I><SMALL>val it : int = 89</SMALL></I>
fibs
<I><SMALL>val it : int list =
   1 :: 1 :: 2 :: 3 :: 5 :: 8 :: 13 :: 21 :: 34 :: 55 :: 89 :: _lazy</SMALL></I></PRE>

<P>For more practical applications of laziness, see the standard literature
on lazy functional programming. Last but not least, note that Alice ML allows
laziness to be combined freely with side effects:</P>

<PRE class=code>
val n = lazy (print "Huhu!\n"; 13)
<I><SMALL>val n : int = _lazy</SMALL></I>
n+1
<I><SMALL>Huhu!
val it : int = 14</SMALL></I></PRE>

<P>Take care with side effects when you do lazy programming!</P>


<?php section("concurrency", "concurrency") ?>

<P>Alice extends SML with support for concurrency. Concurrency is light-weight:
the system can handle tens or hundreds of thousands of concurrent threads.
Concurrent programming in Alice is uniformly based on the model of
<EM>futures</EM>.</P>

<P>A concurrent thread can be initiated by means of the <TT>spawn</TT>
expression:</P>

<PRE class=code>
spawn 45*68
<I><SMALL>val it : int = _future</SMALL></I></PRE>

<P>In this example the value 45*68 is computed in a new thread. The result of
the <TT>spawn</TT> expression is a <EM>future</EM>, a place-holder for the
result of the concurrent computation. Once the result becomes available, the
future will be globally replaced by the result. We say that threads are
<EM>functional</EM>, in the sense that they have a result.</P>

<DIV class=note>
<P><I>Note:</I> If you do not happen to have an ancient machine then you most likely will not have seen
the output above. Instead you have already seen the actual result of the computation, because it performed faster
than the interactive toplevel was able to print it.</P>
</DIV>

<P>The semantics of futures
becomes more obvious if we look at a thread that does not terminate
immediately. For that purpose, let us define the naive version of the Fibonacci
function, which has exponential complexity:</P>

<PRE class=code>
fun fib (0 | 1) = 1
  | fib n       = fib (n-1) + fib (n-2)
<I><SMALL>val fib : int -> int = _fn</SMALL></I></PRE>

<P>On an ordinary desktop PC, computing <TT>fib 35</TT> will take quite some
time. We perform that computation concurrently:</P>

<PRE class=code>
val n = spawn fib 35
<I><SMALL>val n : int = _future</SMALL></I></PRE>

<P>We get back a future, that we can look at using the Inspector:</P>

<PRE class=code>
inspect n
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P align=center><IMG src="inspector-conc-1.png" border=0 alt="Alice Inspector"></P>

<P>At first, the Inspector will display the value as a future, as shown above. <?php if ($platform == "seam") { ?>
You can investigate the type of the value the future is holding place for by using the tool tip feature:</P>

<P align=center><IMG src="inspector-conc-2.png" border=0 alt="Alice Inspector"></P>

<P><?php } ?>
Once the computation of the result finishes and the thread terminates, the
future gets replaced by the thread's result. The Inspector will update its
display accordingly:</P>

<P align=center><IMG src="inspector-conc-3.png" border=0 alt="Alice Inspector"></P>

<P>The situation becomes more interesting if we start several threads at
once:</P>

<PRE class=code>
inspect (List.tabulate (10, fn i => spawn fib (i+25)))
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P>The individual entries from the small table we build are calculated
concurrently and become available individually. At some point in time the
Inspector window might display the following:</P>

<P align=center><IMG src="inspector-conc-4.png" border=0 alt="Alice Inspector"></P>


<?php subsection("concurrency-sync", "Data-flow synchronization") ?>

<P>Futures can be passed around as values. Once an operation
actually <EM>requests</EM> the value the future stands for, the corresponding
thread will block until the future has been determined. This is known as <EM>data-flow
synchronisation</EM> and is a powerful mechanism for high-level concurrent
programming. As a trivial example, consider the following pair of concurrent
producer and consumer that are connected through a message stream:</P>

<PRE class=code>
val delay = Time.fromSeconds (Int.toLarge 2)
<I><SMALL>val delay : Time.time = time{|2000000us|}</SMALL></I>
fun produce 0 = []
  | produce n = spawn (Thread.sleep delay; n :: produce (n-1))
<I><SMALL>val produce : int -> int list = _fn</SMALL></I>
fun consume (n::ns) = (print (Int.toString n ^ "\n"); consume ns)
  | consume   nil   = ()
<I><SMALL>val consume : int list -> 'a = _fn</SMALL></I>
spawn consume (produce 5)
<I><SMALL>val it : unit = _future
5
4
3
2
1</SMALL></I></PRE>

<!-- TODO: Reference? -->

<P>Synchronisation on futures can also be done explicitly, by employing the
library function <A href="library/future.html"><TT>await</TT></A>:</P>

<PRE class=code>
await (spawn fib 30)
<I><SMALL>val it : int = 1346269</SMALL></I></PRE>

<P>Interestingly, <A href="#laziness">lazy suspensions</A> are nothing but a
special form of future, called a <EM>lazy future</EM>. Requesting a lazy future
is triggering the corresponding computation. Consequently,
<TT>await</TT> can also be used to trigger lazy computations
explicitly:</P>

<PRE class=code>
lazy 3+4
<I><SMALL>val it : int = _lazy</SMALL></I>
await it
<I><SMALL>val it : int = 7</SMALL></I></PRE>


<?php subsection("concurrency-failure", "Failed futures") ?>

<P>What happens if a concurrent computation fails, e.g. by raising an exception?
In that case the future will be <EM>failed</EM>. A failed future carries an
exception indicating the cause of the failure. A failed future does not cause
failure of a client by itself. Only when a client actually requests the failed
future, the failure exception will be re-raised at the point of request:</P>

<PRE class=code>
spawn (raise Domain)
<I><SMALL>val it : 'a = _future</SMALL></I>
[1, it, 3]
<I><SMALL>val it : int list = [1, _failed{|Domain|}, 3]</SMALL></I>
10 * List.nth (it, 1)
<I><SMALL>uncaught exception Domain</SMALL></I></PRE>

<P>In the second output, the interactive toplevel uses the notation
<TT>_failed{|exn|}</TT> to indicate a future failed with exception <TT>exn</TT>.</P>

<P>See the <A href="futures.html">manual page</A> on futures for a detailed
discussion of concurrency, futures, and failure.</P>


<?php subsection("concurrency-atomic", "Atomicity") ?>

<P>Dealing with state correctly in a concurrent environment requires the
availability of atomic operations. Alice provides an atomic exchange operation
for references:</P>

<PRE class=code>
val r = ref 10
<I><SMALL>val r : int ref = ref 10</SMALL></I>
Ref.exchange (r, 20)
<I><SMALL>val it : int = 10</SMALL></I></PRE>

<P>The value of the reference is extracted and replaced in one atomic
operation. See <A href="#promises-concurrent">below</A> for an example relying
on this function.</P>

<!--
<P class=note><EM>Note:</EM> Due to limitations of the Mozart virtual machine,
Alice does not yet provide an atomic exchange operation for arrays.</P>
-->

<?php section("promises", "promises") ?>

<P>Functional threads and lazy evaluation offer convenient means to create
futures "on the fly". Often the direct coupling between a future and the
computation delivering its result is too inflexible, however. For such cases,
Alice offers <EM>promises</EM>.</P>

<P>A promise is an explicit handle for a future. When a promise is created,</P>

<PRE class=code>
open Promise
<I><SMALL>val fail : 'a promise * exn -> unit = _fn
val future : 'a promise -> 'a = _fn
val fulfill : 'a promise * 'a -> unit = _fn
val promise : unit -> 'a promise = _fn
val Promise : exn = Promise
exception Promise
type t = t
type promise = promise</SMALL></I>
val p : int promise = promise ()
<I><SMALL>val p : int Promise.promise = promise{|_future|}</SMALL></I></PRE>

<P>an associated future is created along with it. This future can be obtained as
follows:</P>

<PRE class=code>
val x = future p
<I><SMALL>val x : int = _future</SMALL></I></PRE>

<P>Such a <EM>promised future</EM> behaves like a concurrent future, in
particular by allowing dataflow synchronisation. But unlike a concurrent or
lazy future it does not vanish automatically, but has to be eliminated
explicitly through the corresponding promise:</P>

<PRE class=code>
fulfill (p, 19)
<I><SMALL>val it : unit = ()</SMALL></I>
p
<I><SMALL>val it : int Promise.promise = promise{|19|}</SMALL></I>
x
<I><SMALL>val it : int = 19</SMALL></I></PRE>

<P>Intuitively, by creating a future this way, you create a place-holder for a
value that you "promise" to deliver at some later point in time. At that
point, you "fulfill" your promise. <!--You can also break your promise, by failing
the future:</P>

<PRE class=code>
val p : int promise = promise ()
<I><SMALL>val p : int Promise.promise = promise{|_future|}</SMALL></I>
fail (p, Domain)
<I><SMALL>val it : unit = ()</SMALL></I>
p
<I><SMALL>val it : int Promise.promise = promise{|_failed{|Domain|}|}</SMALL></I></PRE>

<P>The future will be failed with the exception you pass to the <TT>fail</TT>
function. Any subsequent attempt to request the future will cause raise of that
exception, just as a failed concurrent future:<P>

<PRE class=code>
1 + future p
<I><SMALL>uncaught exception Domain</SMALL></I></PRE>

<P>-->A promise may only be fulfilled <!--or failed--> once. Hence, a different view on
promises is that of a single assignment reference, yielding the following
correspondences:</P>

<PRE class=code>
type 'a promise                         type 'a ref
promise : unit -> 'a promise            ref : 'a -> 'a ref
future  : 'a promise -> 'a              !   : 'a ref -> 'a
fulfill : 'a promise * 'a -> unit       :=  : 'a ref * 'a -> unit</PRE>

<P>The important point is that a promise is not initialized (hence the
difference in the constructor types), and dereferencing it prior to assignment
delivers a place holder for its potential content.</P>


<?php subsection("promises-topdown", "Top-down construction of data structures") ?>

<P>Usage of promises is not necessarily related to concurrent programming. One
application is the top-down construction of data structures, as opposed to the
bottom-up construction usually required in functional programming. As a simple
example of that we show how promises can be utilised to program a
tail-recursive version of the list append function:</P>

<PRE class=code>
fun append (l1,l2) =
let
    fun iter (nil,   p) = fulfill (p, l2)
      | iter (x::xs, p) =
	let
	    val p' = promise ()
	in
            fulfill (p, x::future p'); iter (xs, p')
	end
    val p = promise ()
in
    iter (l1, p); future p
end
<I><SMALL>val append : 'a list * 'a list -> 'a list = _fn</SMALL></I></PRE>

<!--
<P class=note><EM>Note:</EM> When entering this example interactively you have
to put some white space after the semicolon in the <TT>let</TT> body.
Otherwise, unlike other SML interpreters, the interactive top-level of Alice
will assume it to terminate your input.</P>
-->

<P>This formulation is somehwat reminiscent of the definition of append in logic programming. Its basic idea is to cons the head of the left
operand to a future in each iteration. That future gets replaced by the actual
tail in the next iteration, with the tail again containing a future as its
respective tail. When we reach the end of the list, the last future gets
replaced by the right operand.</P>

<P>In a similar vein, arbitrary data structures can be generated in a top-down
manner by creating promised futures as place holders for parts of it and
construct them afterwards.</P>


<?php subsection("promises-concurrent", "Concurrent data structures") ?>

<P>The primary purpose of promises is to provide a simple primitive that
enables the implementation of high-level concurrency abstractions. We only give an idea of that here,
by showing how promises can encode another well-known concurrency idiom easily:
<EM>channels</EM>.</P>

<P>A channel (sometimes also called a <EM>port</EM>) is a simple imperative
message queue that allows asynchronous communication between processes. As an
abstract data type it can be described by the following signature:</P>

<PRE class=code>
signature CHAN =
sig
    type 'a chan

    val chan : unit -> 'a chan
    val put :  'a chan * 'a -> unit
    val get :  'a chan -> 'a
end
</PRE>

<P>An arbitrary number of messages may be sent to a channel using <TT>put</TT>.
The <TT>get</TT> operation takes the oldest message out of the channel. It
suspends if none is available. A more advanced design might distinguish between
read and write view of a channel, but we ignore that here for the sake
of simplicity.</P>

<P>A straight-forward implementation uses promises and references:</P>

<PRE class=code>
structure Chan : CHAN =
struct
    open Promise

    type 'a chan = 'a list promise ref * 'a list ref

    fun chan () =
	let
	    val p = promise ()
	in
	    (ref p, ref (future p))
	end

    fun put ((putr,getr), x) =
	let
	    val p' = promise ()
	    val p  = Ref.exchange (putr, p')
	in
	    fulfill (p, x::future p')
	end

    fun get (putr, getr) =
	let
            val p' = promise ()
	    val xs = Ref.exchange (getr, future p')
        in
            fulfill (p', tl xs); hd xs
        end
end
</PRE>

<P>The implementation is a variation of a difference list: the first reference
stores the tail of the queue ("write position"), while the second points to
the head ("read position"). Modification of either position is performed by an
atomic exchange operation on the respective reference. That ensures that all
operations are properly sequentialized.</P>

<P>The tail is represented as a promised future. As in the append example
from the previous section this allows constructing the message queue
incrementally in the <TT>put</TT> function.</P>

<P>By using a promised future in the implementation of <TT>get</TT> we can use
atomic exchange although the new value actually depends on the previous one.
Any concurrent <TT>get</TT> operation will block automatically (in <TT>tl</TT>)
until the future is eliminated by fulfilling the promise. Consequently, no
<TT>get</TT> operation can proceed before the former has determined the new
queue. That ensures thread-safety.<P>

<P>Likewise, when the queue is empty, <TT>get</TT> encounters a future for
<TT>xs</TT> and will block. This time, the future is eliminated by the next
<TT>put</TT> operation.</P>

<P>Let us create a channel and observe its content using the Inspector:</P>

<PRE class=code>
val ch : int Chan.chan = Chan.chan ()
<I><SMALL>val ch : int Chan.chan = (ref (promise{|_future|}), ref (_future))</SMALL></I>
inspect ch
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<!--
<P class=note><I>Note:</I> The interactive top-level prints the channel value
as <TT>_val</TT>, indicating an abstract type that cannot be shown. The
Inspector allows looking at values of abstract type, however.</P>
-->

<P align=center><IMG src="inspector-prom-1.png" border=0 alt="Alice Inspector"></P>

<PRE class=code>
Chan.put (ch, 17); Chan.put (ch, 6)
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P align=center><IMG src="inspector-prom-2.png" border=0 alt="Alice Inspector"></P>

<PRE class=code>
(Chan.get ch, Chan.get ch)
<I><SMALL>val it : int * int = (17, 6)</SMALL></I></PRE>

<P align=center><IMG src="inspector-prom-3.png" border=0 alt="Alice Inspector"></P>

<P>Tuples are always evaluated from left to right, so we will deterministically
get the pair <TT>(17,6)</TT> in the last example. To witness non-determinism
due to concurrency, let us set up several clients. They perform an expensive
calculation before reading from the channel, in order to properly randomize
thread scheduling:</P>

<PRE class=code>
fun client _ = spawn (fib 20; Chan.get ch)
<I><SMALL>val client : 'a -> int = _fn</SMALL></I>
inspect (List.tabulate (5, client))
<I><SMALL>val it : unit = ()</SMALL></I>
Chan.put (ch, 1); Chan.put (ch, 2); Chan.put (ch, 3)
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P align=center><IMG src="inspector-prom-4.png" border=0 alt="Alice Inspector"></P>

<P>The order in which the threads will read from the channel is
non-deterministic, but no value will ever get lost or read twice.</P>

<?php subsection("promises-examples", "More examples") ?>

<P>There is a tiny interactive demo demonstrating dataflow synchronisation
using streams:</P>

<UL>
  <LI> <A href="examples/streams.aml"><TT>streams.aml</TT></A> </LI>
</UL>

<P>Compile with:</P>

<PRE class=code>
alicec streams.aml</PRE>

<P>Run with:</P>

<PRE class=code>
alicerun streams</PRE>


<?php section("packages", "packages") ?>

<P>One of the major pros of ML is its powerful static type system. However,
there are programming tasks where it is not possible to perform all typing
statically. For example, consider exchange of data structures between separate
processes. To accompony such tasks of <EM>open programming</EM>, Alice
complements its static type system with a controlled form of dynamic
typing.</P>

<P>Alice provides the type <TT>package</TT> of dynamically typed values. A
<EM>package</EM> essentially is a pair of a (higher-order) module and its
signature. Packages are created using the <TT>pack</TT> expression:</P>

<PRE class=code>
val p = pack Word8 : WORD
<I><SMALL>val p : package = package{|...|}</SMALL></I></PRE>

<P>This example injects the module <TT>Word8</TT> into a package. The signature
constraint (the part following the colon) is part of the pack expression.
It specifies the package's signature. The packaged module must of course match
that signature statically.<P>

<?php if ($platform == "seam") { ?>
<P>Using the Inspector, we can look inside the package:</P>

<PRE class=code>
inspect p
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P align=center><IMG src="inspector-pack-1.png" border=0 alt="Alice Inspector"></P>

<P>We can even investigate its signature:</P>

<P align=center><IMG src="inspector-pack-2.png" border=0 alt="Alice Inspector"></P>
<?php } ?>

<P>The package <TT>p</TT> may be passed to some client, which may unpack it as
follows:</P>

<PRE class=code>
structure Word' = unpack p : WORD
<I><SMALL>structure Word' : WORD</SMALL></I></PRE>

<P>The <TT>unpack</TT> expression also requires a signature being specified.
Unpacking involves a dynamic type check: to evaluate the expression, the
package signature is matched against the specified target signature. If
matching succeeds, the packaged module is returned. Otherwise, an exception is
raised:</P>

<PRE class=code>
structure List' = unpack p : LIST
<I><SMALL>uncaught exception Mismatch</SMALL></I></PRE>

<P>If unpacking succeeds, the client may use the <TT>Word'</TT> structure as
usual. The static signature of <TT>Word'</TT> is determined by the target
signature specified with <TT>unpack</TT>.</P>

<P>Since modules can contain arbitrary values, any value can be wrapped up as
packages. In particular, values can be given polymorphic type in packages:</P>

<PRE class=code>
val p = pack (val x = length) : (val x : 'a list -> int)
<I><SMALL>val p : package = package{|...|}</SMALL></I></PRE>

<P class=note><I>Note:</I> This example uses some <A href="modules.html#sugar">syntactic
sugar</A> of Alice ML, which allows replacing <TT>struct</TT>...<TT>end</TT>
and <TT>sig</TT>...<TT>end</TT> by <TT>(</TT>...<TT>)</TT>.</P>

<P>Unpacking may specify a more restrictive target signature:</P>

<PRE class=code>
structure IntLength = unpack p : (val x : int list -> int)
<I><SMALL>structure IntLength : sig val x : int list -> int end</SMALL></I>
structure RealLength = unpack p : (val x : real list -> int)
<I><SMALL>structure RealLength : sig val x : real list -> int end</SMALL></I></PRE>

<P>The whole range of SML signature matching rules applies, so a package may
have more components than required by the target signature, may have more
general value types, or more specific type components, etc. Using packages
hence is quite robust with respect to extensions.</P>

<P>See the respective <A href="packages.html">manual page</A> for a more
detailed look at the semantics of packages. Packages are the basis of several
other features of Alice, in particular <A href="#pickling">pickling</A> and <A
href="#distribution">distribution</A>.</P>


<?php section("pickling", "pickling") ?>

<P>Applications rarely run in isolation. Many applications need to exchange
data with other applications, or make data persistent between runs.
Consequently, it should be possible to export and import data from processes.
Export of language data structures is often known as <EM>serialization</EM>, or
<EM>pickling</EM>.<P>

<P>Alice provides high-level support for pickling, that is, arbitrary data can be pickled, including code and entire modules. Pickles are platform-independent and are hence suitable for exchange across heterogenous networks, especially the Internet. By pickling first-class functions, Alice processes can exchange behaviour.</P>

<P>The pickling library is based on <A href="#packages">packages</A>.
Consequently, the entities of import/export are modules. This implies that even
types and signatures can be exchanged between processes. Consider a very simple
abstract type as an example:</P>

<PRE class=code>
signature NUM =
sig
    type t
    fun fromInt : int -> t
    fun toInt   : t -> int
    fun add     : t * t -> t
end
<I><SMALL>signature NUM =
   sig
      type t
      val fromInt : int -> t
      val toInt : t -> int
      val add : t * t -> t
   end</SMALL></I>
structure Num :> NUM =
struct
    type t = int
    fun toInt n   = n
    fun fromInt n = n
    val add       = op+
end
<I><SMALL>structure Num : NUM</SMALL></I></PRE>

<DIV class=note>
<P><I>Note:</I> For values of abstract type the toplevel prints place-holders
only. However, the function <A href="library/print.html"><TT>Print.register</TT></A> can be used to install a user-defined printer for abstract types, e.g.
<PRE class=code>
Print.register (Int.toString o Num.toInt)</PRE>
enables the toplevel to print values of type <TT>Num.t</TT> in integer
representation.
<?php if ($platform == "seam") { ?>
Likewise, printers can be installed for the Inspector, using the function
<A href="library/inspector.html"><TT>Inspector.register</TT></A>.
<?php } ?>
</DIV>

<P>A package can be formed from this structure and be written to a file:</P>

<PRE class=code>
Pickle.save ("Num.alc", pack Num : NUM)
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P>To recover the structure in another (or the same) process, one simply
executes the inverse operation:</P>

<PRE class=code>
structure Num' = unpack Pickle.load "Num.alc" : NUM
<I><SMALL>structure Num' : NUM</SMALL></I>
Num'.toInt (Num'.add (Num'.fromInt 4, Num'.fromInt 5))
<I><SMALL>val it : int = 9</SMALL></I></PRE>

<P>Note that the type <TT>Num'.t</TT> is incompatible with the original type
<TT>Num.t</TT>:</P>

<PRE class=code>
Num'.add (Num.fromInt 4, Num.fromInt 5)
<I><SMALL>0.0-0.39: argument type mismatch:
   Num.t * Num.t
does not match argument type
   Num'.t * Num'.t
because type
   Num.t
does not unify with
   Num'.t</SMALL></I></PRE>

<P>The reason is that the signature annotation for <TT>unpack</TT> does not specify the necessary type equivalence - the types are statically incompatible, although <I>we</I> know they are the same dynamically. The usual means of expressing type sharing can be used to induce that knowledge statically:</P>

<PRE class=code>
structure Num' = unpack Pickle.load "Num.alc" : NUM where type t = Num.t
<I><SMALL>structure Num' : 
   sig
      type t = Num.t
      val fromInt : int -> Num.t
      val toInt : Num.t -> int
      val add : Num.t * Num.t -> Num.t
   end</SMALL></I></PRE>

<P>The result signature already indicates the type sharing, making legal</P>

<PRE class=code>
Num'.add (Num.fromInt 4, Num.fromInt 5)
<I><SMALL>val it : Num'.t = _val</SMALL></I></PRE>

<P>Note however, that the type <TT>Num'.t</TT> is still abstract and
incompatible to <TT>int</TT>:</P>

<PRE class=code>
Num'.add (4, 5)
<I><SMALL>v1.0-1.15: argument type mismatch:
   int * int
does not match argument type
   Num'.t * Num'.t
because type
   int
does not unify with
   Num'.t</SMALL></I></PRE>

<!--
<?php subsection("pickling-functors", "Pickling functors") ?>

<P>Since Alice supports <A href="modules.html#higher">higher-order modules</A>,
functors can be pickled as well:</P>

<PRE class=code>
functor MkHello (val who : string) =
struct
    val _ = print ("Hello " ^ who ^ "!\n")
end
<I>functor MkHello : fct (_id2 : sig val who : string end) -> sig end</I>
signature MK_HELLO = fct (val who : string) -> sig val s : string end
<I>signature MK_HELLO =
   fct (_id3 : sig val who : string end) -> sig val s : string end</I>
Pickle.save ("MkHello." ^ Pickle.extension, pack MkHello : MK_HELLO)
<I>val it : unit = ()</I></PRE>
-->

<!--
<?php subsection("pickling-sigs", "Unpickling modules with dynamic signatures") ?>

<P>Due to Alice' <A href="modules.html#sigmembers">nested signatures</A> it is
even possible to load pickles whose signature is statically unknown, as long as
that signature is dynamically available:</P>

<PRE class=code>
val sigfile = "Sig." ^ Pickle.extension
val modfile = "Mod." ^ Pickle.extension

signature X      = sig    type t       end
structure X :> X = struct type t = int end

Pickle.save (modfile, pack X : X)
Pickle.save (sigfile, pack (signature S = X) : (signature S))

structure Sig = unpack Pickle.load sigfile : (signature S)
structure Mod = unpack Pickle.load modfile : Sig.S
</PRE>
-->

<P>See the <A href="pickling.html">manual page</A> on pickling for more detail
on the semantics of pickling.</P>


<?php section("components", "components") ?>

<P>Alice introduces the notion of <EM>component</EM> as the unit of
compilation as well as deployment. Superficially, a component contains a
module expression that, when evaluated, potentially imports modules from other components. An
application will consist of a set of components with one designated "main" or "root" component.</P>

<P>Consider the following trivial component:</P>

<PRE class=code>
(* Fac.aml *)
structure Fac =
struct
    val _ = print "Evaluating component Fac...\n"

    fun fac 0 = Int.toLarge 1
      | fac n = Int.toLarge n * fac (n-1)
end</PRE>

<P>We can compile it invoking the Alice <A href="compiler.html">batch
compiler</A> from a shell:</P>

<PRE class=code>
alicec Fac.aml</PRE>

<P>If the interactive toplevel has been started in the same directory, the
compiled component can be imported interactively:</P>

<PRE class=code>
import "Fac"
<I><SMALL>### loaded signature from file:/home/user/Fac
structure Fac : sig val fac : int -> IntInf.int end = Fac</SMALL></I></PRE>

<P>Loading is performed lazily: the interactive toplevel will load the
signature from the component file, but it will not yet evaluate (execute) the
component. This is appearent from the fact that the message contained in the
structure has not been printed in the above example. We can also see it when
accessing a structure field:</P>

<PRE class=code>
Fac.fac
<I><SMALL>val it : int -> IntInf.int = _lazy</SMALL></I></PRE>

<P>The function is represented by a <A href="#laziness">lazy future</A>. The
component will be evaluated when its content is first requested:</P>

<PRE class=code>
Fac.fac 23
<I><SMALL>Evaluating component Fac...
val it : IntInf.int = 25852016738884976640000</SMALL></I>
Fac.fac 46
<I><SMALL>val it : IntInf.int =
   5502622159812088949850305428800254892961651752960000000000</SMALL></I></PRE>

<P>Let us write a little application using the <TT>Fac</TT> component. We simply
implement an appropriate main component:</P>

<PRE class=code>
(* Main.aml *)
import structure Fac from "Fac"

structure Main =
struct
    fun main () =
	let
	    val _ = TextIO.print "Input number: "
	    val n = valOf (Int.fromString (valOf (TextIO.inputLine TextIO.stdIn)))
	in
	    TextIO.print (IntInf.toString (Fac.fac n) ^ "\n"); 
	    OS.Process.success
	end
	handle Option => (TextIO.print "error\n"; OS.Process.failure)

    val _ = OS.Process.exit (main ())
end</PRE>

<P>This component imports the structure from the previous component by using an
<EM>import announcement</EM>. Every component can be headed by an arbitrary
number of such import announcements. The <TT>Main</TT> component is compiled in the usual way:</P>

<PRE class=code>
alicec Main.aml</PRE>

<P>Note that the compiler needs to access all compiled components that are
imported, in order to perform its type checking (that also is the reason why the
interactive toplevel had to load the signature of component <TT>Fac</TT>). We
can run our little application using the Alice <A href="machine.html">virtual
machine</A>:</P>

<PRE class=code>
alicerun Main
<I><SMALL>Input number: </SMALL></I>34
<I><SMALL>Evaluating component Fac...
295232799039604140847618609643520000000</SMALL></I></PRE>

<P>You can again observe that imports are performed lazily. If the <TT>Fac</TT>
component is never accessed, it will not be loaded at all:</P>

<PRE class=code>
alicerun Main
<I><SMALL>Input number: </SMALL></I>gnalp
<I><SMALL>error</SMALL></I></PRE>


<?php subsection("components-typechecking", "Link-time type checking") ?>

<P>A component carries its signature and the signatures of all its imports. You
can inspect them using the Alice <A href="linker.html">linker</A>:</P>

<PRE class=code>
alicelink -d Main
<I><SMALL>import
   structure TextIO :
      sig
         type instream
         val inputLine : instream -> string option
         val stdIn : instream
         val print : string -> unit
      end
from "x-alice:/lib/system/TextIO"
import
   structure OS :
      sig
         structure Process :
            sig
               type status
               val success : status
               val failure : status
               val exit : status -> 'a
            end
      end
from "x-alice:/lib/system/OS"
import structure Fac : sig val fac : int -> int end from "Fac"
structure Main : sig val main : unit -> OS.Process.status end</SMALL></I></PRE>

<P>The output first lists all imports required by the component (which includes
necessary parts of the <A href="library/index.html">library</A>) and then the
signature of its own export - in this case the last line. Note that import
locations are actually denoted by URLs. In this tutorial we will only make use
of file URLs, but components can actually be imported from arbitrary
locations in the Internet via HTTP addresses.</P>

<P>Before a component is evaluated at runtime, its export signature is matched
against the import signature of the component that imports and requests it. If
that match fails, all references to items from the component are replaced by
failed futures. We can observe this if we modify and recompile our <TT>Fac</TT>
component in an incompatible way without adapting <TT>Main</TT>:

<PRE class=code>
(* Fac.aml modified *)
structure Fac =
struct
    val _ = print "Evaluating component Fac...\n"

    fun fac (0,n) = n
      | fac (i,n) = fac (i-1, i*n)   (* tail-recursive *)
end</PRE>

<P>An attempt to run the application without adapting <TT>Main</TT> properly
will cause a runtime failure:</P>

<PRE class=code>
alicec Fac.aml
alicerun Main
<I><SMALL>Input number: </SMALL></I>20
<I><SMALL>Evaluating component Fac...</SMALL></I>
<I><SMALL>error</SMALL></I></PRE>

<P>An application that strives to be robust against such failures should handle
the corresponding exceptions. See the <A href="components.html">manual
pages</A> on components for more details.</P>

<P>A way to avoid such errors is to statically <EM>link</EM> all components of
the application using the <A href="linker.html">static linker</A>:</P>

<PRE class=code>
alicelink ./Main --include ./ -o LinkedMain.acl
<I><SMALL>alicelink: signature of component
./Fac
does not match import requirement of component
./Main
Try recompiling the latter.</SMALL></I></PRE>

<P>Oops! The linker verifies whether all import/export signatures are compatible. Of course, this is not the case since we intentionally made <TT>Fac</TT> incompatible. Recompiling <TT>Main</TT>, as the linker suggests, will not help either in this case.</P>

<P>But if we revert <TT>Fac</TT> to its original form and recompile it, the
linker will happily accept it:</P>

<PRE class=code>
alicec Fac.aml
alicelink ./Main --include ./ -o LinkedMain.acl</PRE>

<P>The linker builds a new component that bundles all components that are directly or
indirectly imported by the <EM>root component</EM> given on the command line
- in this case, <TT>Main</TT> - <EM>and</EM> that match the include pattern
specified. See the <A href="linker.html">manual page</A> for details.</P>


<?php subsection("components-pickles", "Relation to pickling") ?>

<P>There is a close connection between components and pickles. Actually, they
are interchangable: a pickle <EMPH>is</EMPH> a component! It can be imported
using import announcements. On the flipside, any component can be loaded as
a pickle. Doing so will evaluate the component.</P>

<P>As a consequence, Alice enables the <EMPH>dynamic creation</EMPH> of components. That is, components can be created by a running Alice program.
For example, this feature allows us to construct precomputed components by
writing a component that computes it and writes it into an appropriate
pickle:</P>

<PRE class=code>
structure Fac50 = struct val x = Fac.fac 50 end
<I><SMALL>structure Fac50 : sig val x : IntInf.int end</SMALL></I>
Pickle.save ("Fac50.alc",
	     pack (structure Fac50 = Fac50)
	        : (structure Fac50 : sig val x : IntInf.int end))
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P>Assume that calculating the factorial of 50 is an expensive computation. We
have now performed it statically and generated a component that exports the
result as a value. We may import it as usual:</P>

<PRE class=code>
import structure Fac50 from "Fac50"
<I><SMALL>### loaded signature from file:/home/rossberg/Fac50
structure Fac50 : sig val x : IntInf.int end = Fac50</SMALL></I>
Fac50.x
<I><SMALL>val it : IntInf.int = _lazy</SMALL></I>
await Fac50.x
<I><SMALL>val it : IntInf.int =
   30414093201713378043612608166064768844377641568960512000000000000</SMALL></I></PRE>

<P>A pickle is an <EM>evaluated component</EM>. Evaluated components are
closed, i.e. they never depend on any import:</P>

<PRE class=code>
alicelink -d Fac50
<I><SMALL>structure Fac50 : sig val x : int end</SMALL></I></PRE>

<P>The linker shows that there is only an export signature to this component.
See the <A href="components.html#evaluated">manual pages</A> on components for
more information on evaluated components.</P>

<?php subsection("components-manager", "Component managers") ?>

<P>Linking of components is handled by the system's <EM>component manager</EM>.
Applications may configure the component manager and the attached
<EM>resolver</EM> to adapt to their needs, or may even set up their own
component managers. Component managers essentially allow to achieve what is
often called <EM>sandbox security</EM> for untrusted components. See the <A
href="library/component-manager.html">library reference</A> for more
detail.</P>


<?php subsection("components-example", "Application example") ?>

<P>The implementation of an interpreter for a simple functional language
demonstrates how an application can be divided into components:</P>

<UL>
  <LI> <A href="examples/interpreter/">source directory</A> </LI>
  <LI> <A href="examples/interpreter.tar"><TT>tar file</TT></A> </LI>
</UL>

<P>See <TT>readme.txt</TT> for build instructions.</P>



<?php section("distribution", "distribution") ?>

<P><A href="#components">Components</A> and <A href="#pickling">pickles</A>
already provide a primitive form of distributed programming, since they may be
imported or loaded from arbitrary locations across a local network or even the
Internet. But Alice also provides high-level means for processes at different
sites to communicate directly.</P>

<?php subsection("distribution-tickets", "Tickets") ?>

<P>The first mechanism that allows sites to establish peer-to-peer connections
is <EM>offer and take</EM>. A process can create a package and make it available
to other processes, for example the <TT>Num</TT> structure from the previous
section:</P>

<PRE class=code>
val t = Remote.offer (pack Num : NUM)
<I><SMALL>### loaded signature from x-alice:/lib/distribution/Remote
val t : ticket = "x-alice://134.96.186.172:46849/ticket/0"</SMALL></I></PRE>

<P>Offering a package opens a communication port and returns an URI for that
port. The URI is called a <EM>ticket</EM>. A ticket can be transferred to other
sites, say by email or through some web document. Other sites can
then obtain the available package using the ticket. Of course, the exporting
site may also obtain it itself (which we will do in this interactive example for
the sake of simplicity):</P>

<PRE class=code>
val p = Remote.take t
<I><SMALL>val p : Package.package = package{|...|}</SMALL></I>
structure Num' = unpack p : NUM
<I><SMALL>structure Num' : NUM</SMALL></I>
Num'.toInt (Num'.fromInt 444)
<I><SMALL>val it : int = 444</SMALL></I></PRE>

<P>In general, <TT>take</TT> establishes a connection to the communication port
denoted by the ticket, and retrieves the offered package. Transfer of the
package is defined by the pickling/unpickling semantics, i.e. the whole closure
of the package is transferred to the client, including any code representing
embedded functions.</P>

<?php subsection("distribution-proxies", "Proxies") ?>

<P>Tickets are intended merely as a means to establish an initial connection
between sites. All subsequent communication should be dealt with by the
functions in the offered package. Alice provides a very simple feature to
enable this idiom: <EM>proxies</EM>. A proxy is basically an RPC stub, a mobile reference to a
stationary function that can be used in place of the function it
references.</P>

<P>The library function</P>

<PRE class=code>
Remote.proxy : ('a -> 'b) -> ('a -> 'b)</PRE>

<P>creates a proxy for an arbitrary function:<P>

<PRE class=code>
fun fib (0 | 1) = 1
  | fib n       = fib (n-1) + fib (n-2)
<I><SMALL>val fib : int -> int = _fn</SMALL></I>
val fib' = Remote.proxy fib
<I><SMALL>val fib' : int -> int = _fn</SMALL></I></PRE>

<P>The resulting function has the same type as the function it references. When
it is applied, all arguments are forwarded to the original function, and the result is transferred back:</P>

<PRE class=code>
fib' 20
<I><SMALL>val it : int = 10946</SMALL></I></PRE>

<P>Pickling a proxy does only pickle the respective reference and <EMPH>not</EMPH>
the referenced function. When the proxy is transferred to a different
site - e.g. by offering it as part of a package - and then applied at that
site, all arguments will be automatically transferred to the site hosting the
referenced function, the result will be computed there, and finally transferred
back to the client site. That is, applying a proxy is practically a remote
procedure call (RPC). Transfer is again defined by pickling semantics.</P>

<?php subsection("distribution-example", "Example") ?>

<P>As a most general example consider a <EM>compute server</EM>, a server which
offers its computational resources to clients. Such a server can be described
by the following signature:</P>

<PRE class=code>
signature COMPUTE_SERVER =
sig
    val compute : ('a -> 'b) * 'a -> 'b
end</PRE>

<P>It can be given a function and an appropriate argument and it will compute
the result of applying the function to the argument.</P>

<P>Such a server is easily set up by packaging the straight-forward
implementation of this signature and offering it to other processes. A slight complication is that, due to ML's value restriction on polymorphic typing, we cannot use the <TT>proxy</TT> function to create a polymorphic proxy. Instead, we use the polymorphic functor</P>

<PRE class=code>
Remote.Proxy (signature S structure X : S) : S</PRE>

<P>that allows wrapping all functions in a structure into proxies in one go:</P>

<PRE class=code>
structure ComputeServer =
    Remote.Proxy (signature S = COMPUTE_SERVER
                  structure X = (fun compute (f,x) = f x))
<I><SMALL>structure ComputeServer : COMPUTE_SERVER</SMALL></I>
val ticket = Remote.offer (pack ComputeServer : COMPUTE_SERVER)
<I><SMALL>val ticket : ticket = "x-alice://134.96.186.172:46849/ticket/1"</SMALL></I></PRE>

<P>Assume that the local HTTP server's domain is <TT>www.mydomain.net</TT> and
the root of its document tree is in directory <TT>/www</TT> of the local file
system. The server may store the ticket as a WWW document:</P>

<PRE class=code>
Pickle.save ("/www/computeserver.ticket",
             pack (val x = ticket) : (val x : string))
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P>A client can retrieve the (dynamically created) ticket from the (statically
known) ticket URL:</P>

<PRE class=code>
structure Ticket = unpack Pickle.load "http://www.mydomain.net/computeserver.ticket"
                        : (val x : string)
<I><SMALL>structure Ticket : sig val x : string end</SMALL></I></PRE>

<P>Note that we could perfectly well have exchanged the ticket in text form using ordinary file I/O, but pickling made it slightly more convenient.</P>

<P>The client can now establish a connection by taking the offered package and
unpacking it under the agreed-upon signature:</P>

<PRE class=code>
structure Server = unpack Remote.take Ticket.x : COMPUTE_SERVER
<I><SMALL>structure Server : COMPUTE_SERVER</SMALL></I></PRE>

<P>Using the <TT>Server</TT> stub the client can shift its comutational load to
the compute server:<P>

<PRE class=code>
Server.compute (fib, 30)
<I><SMALL>val it : IntInf.int = 1346269</SMALL></I></PRE>

<P>The application transfers the function <TT>fib</TT>, as well as the argument
<TT>30</TT>, to the server, which evaluates it. When it is done, it returns the
result.</P>

<P>It is important to note that only establishing the initial connection
requires a dynamic type check with this idiom! All subsequent uses of the
transferred structure in general, and the contained proxy in particular do
not require any check. Communication via proxies is always statically
type-safe!</P>

<?php subsection("distribution-async", "Asynchronous communication") ?>

<P>You will have noticed that the remote call to the server is synchronous,
i.e. the client will not proceed before the server delivers the result.
However, a synchronous call can trivially be transformed into an asynchronous
one using <A href="#concurrency">functional threads</A>!</P>

<PRE class=code>
spawn Server.compute (fib, 40)
<I><SMALL>val it : int = _future</SMALL></I></PRE>

<P>Functional threads and futures hence are a high-level mechanism to improve
<EM>lag latency</EM> in distributed applications - a client can proceed
concurrently to the server and has to suspend only when it actually requires
the result of a remote operation that the server has not yet delivered.</P>

<?php subsection("distribution-remote", "Remote execution") ?>

<P>Sometimes applications themselves need to create new processes at remote
sites. This is known as <EM>remote execution</EM>. Remote execution can be
initiated using the <A href="library/remote.html#Run">Run</A> library
functor. See the respective <A href="distribution.html">manual page</A> for
more about distribution in general and remote exection in particular.</P>



<?php section("constraints", "constraints") ?>

<P>Alice ML provides full support for state-of-the-art constraint programming
technology. Constraint-based problem solving is a technique for solving hard
combinatorial problems that can be stated as variables ranging over a finite
domain of non-negative integers, or sets thereof. Problems in this class range
from puzzles to real world applications as diverse as scheduling, ware house
allocation, configuration and placement.</P>

<P>Let us take a look at programming with <I>finite domain</I>
constraints. A finite domain (FD) is a set of natural (non-negative integer)
numbers. An FD <I>constraint</I> is a formula in predicate logic, containing
variables ranging over the natural numbers. In particular, a domain constraint
is a constraint that restricts the domain of a particular variable. A
<I>finite domain problem</I> is a finite set of quantifier-free constraints
that contains a domain constraint for every variable occurring in it. A
<I>solution</I> is a variable assignment that satisfies every constraint of the
problem.</P>

<?php if ($platform != "seam") { ?>

<P>Let us create some finite domain variables. We use the <A
href="library/linear.html"><TT>Linear</TT></A> library for linear
constraints:</P>

<PRE class=code>
open Linear
<I><SMALL>### loaded signature from x-alice:/lib/constraints/Linear
...</SMALL></I></PRE>

<P>To create a vector of constraint variables <I>x</I>,<I>y</I>,<I>z</I>, the
<TT>vec</TT> function can be used:</P>

<PRE class=code>
val #[x,y,z] = vec (3, [1`#10])
<I><SMALL>val x : term = FD (_val)
val y : term = FD (_val)
val z : term = FD (_val)</SMALL></I></PRE>

<P>The arguments to <TT>vec</TT> specify the number of constraint variables
(the size of the vector) and the initial domain {1,...,10} of each of these
variable. Every constraint variable must be created specifying such a domain
constraint. Constraint variables can be investigated using the Inspector:</P>

<PRE class=code>
inspect {x,y,z}
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P align=center><IMG src="inspector-fd-1.jpg" border=0 alt="Alice Inspector"></P>

<P>For each variable, the Inspector shows the current set of values that still
might form a solution. The set of values still considered for a variable is
called its domain. Since we have not yet posted any constraints, the domains
are given by the initial domain constraints on the variables. The set of all
constraint variables and their domains is called the <I>constraint
store</I>.</P>

<P>The solution set can be restricted by posting constraints. For example, we
can require that 2<I>x</I> = <I>y</I>:</P>

<PRE class=code>
post (`2 `* x `= y)
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P class=note><EM>Note:</EM> Be aware of the backquotes prefixing numbers and
operators in the constraint formula - <TT>`*</TT> and <TT>`=</TT> are infix
functions, while the backquote preceeding the literal <TT>2</TT> is an ordinary
nonfix function.</P>

<P>The posted constraint will exclude certain values from the solution set.
This is reflected by shrinking the domains of the respective constraint
variables. After posting the above constraint, the Inspector recognizes that
the domains of the displayed constraint variables have changed and updates its
display accordingly:</P>

<P align=center><IMG src="inspector-fd-2.jpg" border=0 alt="Alice Inspector"></P>

<P>Adding a constraint can affect the domain of variables that do not even
occur in its formula, because information will be <I>propagated</I> in the
constraint store so that additional information can be inferred in combination
with other posted constraints:</P>

<PRE class=code>
post (z `< x)
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P align=center><IMG src="inspector-fd-3.jpg" border=0 alt="Alice Inspector"></P>

<PRE class=code>
post (y `&lt; `7)
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P align=center><IMG src="inspector-fd-4.jpg" border=0 alt="Alice Inspector"></P>

<P>The information encapsulated in the constraint store grows monotonically. A
variable is determined if its domain is reduced to a singleton set. A solution
is found when all variables are determined.</P>

<PRE class=code>
post (z `&lt;&gt; `1)
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P align=center><IMG src="inspector-fd-5.jpg" border=0 alt="Alice Inspector"></P>

<P>Constraint propagation is not a complete solution method. It may happen that
a problem has a unique solution and that constraint propagation does not find
it. In those cases it is necessary to combine constraint propagation with
search. Alice hence also provides support for powerful, user-definable search
techniques. For a more thorough introduction to constraint programming, we
refer to the Oz <A href="http://www.mozart-oz.org/documentation/fdt/">Finite
Domain Constraint Programming Tutorial</A>. All constraint programming
functionality from Oz is available in Alice, albeit with somewhat different
interfaces.</P>


<?php subsection("constraints-example", "Example") ?>

<?php } ?>


<P>As a simple example of a complete program solving a finite domain problem,
consider the <I>Send More Money</I> problem. It consists in finding distinct
digits for the letters <TT>S</TT>, <TT>E</TT>, <TT>N</TT>, <TT>D</TT>,
<TT>M</TT>, <TT>O</TT>, <TT>R</TT>, <TT>Y</TT> such that <TT>S</TT> and
<TT>M</TT> are different from zero (no leading zeros) and the equation

<PRE class=code>
SEND + MORE = MONEY</PRE>

<P>is satisfied. The unique solution of the problem is <TT>9567 + 1085 =
10652</TT>.</P>

<P>Using Alice, the problem can be solved as follows. First, we have
to import the constraint library and define a so-called <I>script</I>
that encodes the problem:</P>

<PRE class=code>
import structure FD       from "x-alice:/lib/gecode/FD"
import structure Modeling from "x-alice:/lib/gecode/Modeling"
open Modeling

fun money sp =
let
    val v as #[S,E,N,D,M,O,R,Y] = fdtermVec (sp, 8, [0`#9])
in
    distinct (sp, v, FD.BND); 
    post (sp, S `&lt;&gt; `0, FD.BND); 
    post (sp, M `&lt;&gt; `0, FD.BND); 
    post (sp, `1000`*S `+ `100`*E `+ `10`*N `+ D `+
              `1000`*M `+ `100`*O `+ `10`*R `+ E `=
             `10000`*M `+ `1000`*O `+ `100`*N `+ `10`*E `+ Y, FD.BND); 
    branch (sp, v, FD.B_SIZE_MIN, FD.B_MIN); 
    {S,E,N,D,M,O,R,Y}
end
<I><SMALL>val money :
   Modeling.space ->
      {D : term, E : term, M : term, N : term, O : term, R : term, S : term,
       Y : term} = _fn</SMALL></I></PRE>

<P>The Send More Money problem cannot be solved using constraint propagation
alone. Search is required to reduce the problem space until constraint
propagation is able to determine the solution. The <TT>distribute</TT> function
in the script specifies the <I>distribution strategy</I> used when the problem
space has to be split for search. See the Mozart <A
href="http://www.mozart-oz.org/documentation/fdt/">Constraint Programming
Tutorial</A> for a more detailed explanation of the basic concepts.</P>

<P>To perform the actual search and obtain all solutions to the problem,
predefined search engines can be used:</P>

<PRE class=code>
import structure Search from "x-alice:/lib/gecode/Search"
Search.searchAll money
<I><SMALL>
val it :
   Space.space list *
      {D : term, E : term, M : term, N : term, O : term, R : term, S : term,
       Y : term} =
   ([_val],
    {D = FD (_val), E = FD (_val), M = FD (_val), N = FD (_val), O = FD (_val),
     R = FD (_val), S = FD (_val), Y = FD (_val)})</SMALL></I></PRE>

<?php if ($platform != "seam") { ?>

<P>Using the inspector, we can easily look at the solution:</P>

<PRE class=code>
inspect it
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P align=center><IMG src="inspector-fd-6.jpg" border=0 alt="Alice Inspector"></P>

<P>An alternative way to obtain the solutions is by interactively exploring the
search tree induced by the script using the <A
href="library/explorer.html"><EM>Explorer</EM></A>:</P>

<?php } else { ?>

<P>The actual solutions could now be extracted from the result record using the functions from the <A
href="library/fd.html"><TT>FD.Reflect</TT></A> library structure. However, the easiest way to obtain the solutions is to interactively explore the
search tree induced by the script using the <A
href="library/explorer.html"><EM>Explorer</EM></A> instead of offline <TT>Search</TT>:</P>

<?php } ?>

<PRE class=code>
import structure Explorer from "x-alice:/lib/tools/Explorer"

Explorer.exploreAll money
<I><SMALL>val it : unit = ()</SMALL></I></PRE>

<P align=center><IMG src="explorer.png" border=0 alt="Alice Explorer"></P>

<P>Double-clicking on the only solution node in the search tree (the green
diamond) will open an Inspector window displaying the variable assignments of
the solution.
<?php if ($platform == "seam") { ?>
</P>

<P align=center><IMG src="inspector-search-1.png" border=0 alt="Alice Inspector"></P>

<P>
<?php } ?>
Chosing an inner node will display the information available at
the respective point of the search tree.</P>



<?php if ($platform != "seam") { ?>

<?php section("interop", "interoperability") ?>

<P>The Alice compiler generates Oz pickled functors (<TT>.ozf</TT> files). The
Alice virtual machine is essentially a slightly beefed-up version of the Mozart
VM. As such, it can also run ordinary Oz applications.</P>

<P>More importantly, it is easily possible to create mixed Alice/Oz
applications. Oz code can import Alice functors as if they were Oz functors.
Alice can import Oz functors, if given an additional signature description file,
which specifies the types of the entities imported.</P>

<P>The possibility to mix Alice and Oz provides a smooth migration path for Oz
projects that want to use Alice. It also allows escaping the statically typed
world of ML for arbitrary subsystems, where that may be desirable. See the <A
href="interop.html">manual page</A> on interoperability for more detail.</P>

<?php } ?>

<?php footing() ?>
